/// Git hooks installer - Pure Rust implementation
///
/// Installs pre-commit hooks for Trueno development that enforce:
/// - SIMD attribute validation (prevents missing #[target_feature])
/// - Prevents commits causing 5.9x-21x performance degradation

use anyhow::{Context, Result};
use colored::Colorize;
use std::fs;
use std::path::Path;

const PRE_COMMIT_HOOK: &str = r#"#!/bin/bash
# Pre-commit hook: SIMD attribute validation (generated by cargo xtask install-hooks)
#
# This hook runs the Rust-based SIMD property checker to ensure:
# 1. [CRITICAL] All SIMD functions have #[target_feature] attributes
# 2. [ERROR] Attributes match the intrinsics actually used
# 3. [ERROR] FMA intrinsics include 'fma' feature
#
# To bypass (EMERGENCY ONLY): git commit --no-verify

set -e

echo "üîç Running SIMD attribute validation..."
echo ""

# Run the Rust-based checker
if cargo run --quiet --package xtask -- check-simd; then
    exit 0
else
    echo ""
    echo "‚ùå Pre-commit check FAILED"
    echo ""
    echo "To bypass this check (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi
"#;

/// Install git hooks into .git/hooks/
pub fn run() -> Result<()> {
    println!("{}", "üîß Installing git hooks...".blue().bold());
    println!();

    // Check if .git directory exists
    if !Path::new(".git").exists() {
        anyhow::bail!(
            "{}",
            "‚ùå Error: .git directory not found\n   Please run this command from the repository root"
                .red()
        );
    }

    // Create .git/hooks directory if it doesn't exist
    let hooks_dir = Path::new(".git/hooks");
    fs::create_dir_all(hooks_dir)
        .context("Failed to create .git/hooks directory")?;

    // Install pre-commit hook
    let pre_commit_path = hooks_dir.join("pre-commit");

    // Check if hook already exists
    if pre_commit_path.exists() {
        println!("{}", "‚ö†Ô∏è  Pre-commit hook already exists".yellow());
        println!("{}", "   Backing up to pre-commit.backup".yellow());

        let backup_path = hooks_dir.join("pre-commit.backup");
        fs::copy(&pre_commit_path, &backup_path)
            .context("Failed to backup existing pre-commit hook")?;
    }

    // Write the hook
    fs::write(&pre_commit_path, PRE_COMMIT_HOOK)
        .context("Failed to write pre-commit hook")?;

    // Make it executable (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&pre_commit_path)?.permissions();
        perms.set_mode(0o755); // rwxr-xr-x
        fs::set_permissions(&pre_commit_path, perms)
            .context("Failed to make pre-commit hook executable")?;
    }

    println!("{}", "‚úÖ Installed pre-commit hook: SIMD attribute validation".green());
    println!();

    // Summary
    println!("{}", "üéâ Git hooks installed successfully!".green().bold());
    println!();
    println!("The following checks will run before each commit:");
    println!("  ‚Ä¢ SIMD attribute validation (cargo xtask check-simd)");
    println!();
    println!("To bypass hooks (EMERGENCY ONLY):");
    println!("  git commit --no-verify");
    println!();

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pre_commit_hook_content() {
        // Verify hook contains required elements
        assert!(PRE_COMMIT_HOOK.contains("cargo xtask check-simd"));
        assert!(PRE_COMMIT_HOOK.contains("#!/bin/bash"));
        assert!(PRE_COMMIT_HOOK.contains("exit"));
    }
}
