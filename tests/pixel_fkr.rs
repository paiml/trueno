//! TRUENO-SPEC-013: Pixel FKR (Falsification Kernel Regression) Test Suites
//!
//! Visual pixel-level regression tests using Popperian falsification methodology.
//! Each suite renders compute outputs as data and compares against golden baselines.
//!
//! # Test Suites (SPEC Section 3.5)
//! - scalar-pixel-fkr: Baseline truth (pure Rust, no SIMD/GPU)
//! - simd-pixel-fkr: SSE2/AVX2/AVX-512/NEON vs scalar baseline
//! - wgpu-pixel-fkr: WGSL compute shaders vs scalar baseline
//! - ptx-pixel-fkr: CUDA PTX kernels vs scalar baseline
//!
//! # Running
//! ```bash
//! make pixel-fkr-all         # All suites
//! make pixel-scalar-fkr      # Baseline only
//! ```
//!
//! # Academic Foundation
//! - Alipour et al. (ESEC/FSE 2021): Pixel comparison catches bugs unit tests miss
//! - Lidbury et al. (PLDI 2015): Randomized inputs expose corner cases

use std::collections::HashMap;
use std::sync::OnceLock;

// Tolerance constants (SPEC Section 3.5.1)
const SCALAR_TOLERANCE: f32 = 0.0; // Exact match for baseline
const SIMD_TOLERANCE: f32 = 1e-6; // +-1 ULP for SIMD rounding
const GPU_TOLERANCE: f32 = 1e-5; // +-2 ULP for GPU FP variance

// Global storage for golden baselines (generated by scalar tests)
static GOLDEN_BASELINES: OnceLock<HashMap<String, Vec<f32>>> = OnceLock::new();

fn get_golden_baselines() -> &'static HashMap<String, Vec<f32>> {
    GOLDEN_BASELINES.get_or_init(HashMap::new)
}

// ============================================================================
// REALIZER CORE OPERATIONS (Scalar implementations as ground truth)
// ============================================================================

/// RMS Norm (LLaMA normalization) - scalar implementation
fn scalar_rmsnorm(x: &[f32], weight: &[f32], eps: f32) -> Vec<f32> {
    let n = x.len();
    let sum_sq: f32 = x.iter().map(|v| v * v).sum();
    let rms = (sum_sq / n as f32 + eps).sqrt();

    x.iter()
        .zip(weight.iter())
        .map(|(xi, wi)| (xi / rms) * wi)
        .collect()
}

/// SiLU activation (LLaMA FFN) - scalar implementation
fn scalar_silu(x: &[f32]) -> Vec<f32> {
    x.iter().map(|xi| xi * (1.0 / (1.0 + (-xi).exp()))).collect()
}

/// Softmax - scalar implementation with numerical stability
fn scalar_softmax(x: &[f32]) -> Vec<f32> {
    let max_val = x.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
    let exp_vals: Vec<f32> = x.iter().map(|xi| (xi - max_val).exp()).collect();
    let sum: f32 = exp_vals.iter().sum();
    exp_vals.iter().map(|e| e / sum).collect()
}

/// RoPE (Rotary Position Embedding) - scalar implementation
fn scalar_rope(x: &[f32], freqs_cos: &[f32], freqs_sin: &[f32]) -> Vec<f32> {
    let n = x.len();
    let half = n / 2;
    let mut out = vec![0.0f32; n];

    for i in 0..half {
        let x0 = x[i];
        let x1 = x[i + half];
        let cos = freqs_cos[i];
        let sin = freqs_sin[i];

        out[i] = x0 * cos - x1 * sin;
        out[i + half] = x0 * sin + x1 * cos;
    }

    out
}

/// Causal mask application - scalar implementation
fn scalar_causal_mask(scores: &[f32], seq_len: usize) -> Vec<f32> {
    let mut out = scores.to_vec();
    for i in 0..seq_len {
        for j in (i + 1)..seq_len {
            out[i * seq_len + j] = f32::NEG_INFINITY;
        }
    }
    out
}

/// Q4_K block dequantization (simplified) - scalar implementation
fn scalar_q4k_dequant(quantized: &[u8], scale: f32, zero_point: f32) -> Vec<f32> {
    quantized
        .iter()
        .flat_map(|byte| {
            let low = (byte & 0x0F) as f32;
            let high = ((byte >> 4) & 0x0F) as f32;
            vec![(low - zero_point) * scale, (high - zero_point) * scale]
        })
        .collect()
}

/// Compute RoPE frequencies
fn compute_rope_freqs(dim: usize, base: f32) -> (Vec<f32>, Vec<f32>) {
    let half = dim / 2;
    let mut freqs_cos = vec![0.0f32; half];
    let mut freqs_sin = vec![0.0f32; half];

    for i in 0..half {
        let freq = 1.0 / base.powf(2.0 * i as f32 / dim as f32);
        freqs_cos[i] = freq.cos();
        freqs_sin[i] = freq.sin();
    }

    (freqs_cos, freqs_sin)
}

/// Simple deterministic RNG for test data
struct SimpleRng {
    state: u64,
}

impl SimpleRng {
    fn new(seed: u64) -> Self {
        Self { state: seed }
    }

    fn next_f32(&mut self) -> f32 {
        // xorshift64
        self.state ^= self.state << 13;
        self.state ^= self.state >> 7;
        self.state ^= self.state << 17;
        (self.state as f32 / u64::MAX as f32) * 2.0 - 1.0 // Range [-1, 1]
    }

    fn gen_vec(&mut self, n: usize) -> Vec<f32> {
        (0..n).map(|_| self.next_f32()).collect()
    }
}

// ============================================================================
// SCALAR-PIXEL-FKR: Baseline Truth (SPEC Section 3.5.2)
// ============================================================================

/// scalar-pixel-fkr test: RMS Norm
#[test]
fn scalar_pixel_fkr_rmsnorm() {
    let mut rng = SimpleRng::new(12345);
    let x = rng.gen_vec(4096);
    let weight = rng.gen_vec(4096);

    let result = scalar_rmsnorm(&x, &weight, 1e-5);

    // Verify output properties
    assert_eq!(result.len(), 4096);
    assert!(result.iter().all(|v| v.is_finite()), "Non-finite value in RMS norm");

    println!("scalar_pixel_fkr_rmsnorm: {} elements, max={:.6}",
             result.len(),
             result.iter().cloned().fold(f32::NEG_INFINITY, f32::max));
}

/// scalar-pixel-fkr test: SiLU
#[test]
fn scalar_pixel_fkr_silu() {
    let mut rng = SimpleRng::new(23456);
    let x = rng.gen_vec(8192);

    let result = scalar_silu(&x);

    // Verify SiLU properties
    assert_eq!(result.len(), 8192);
    // SiLU(x) should be bounded for bounded input
    for (i, (xi, yi)) in x.iter().zip(result.iter()).enumerate() {
        if *xi > 0.0 {
            assert!(*yi > 0.0, "SiLU should be positive for positive input at {i}");
        }
    }

    println!("scalar_pixel_fkr_silu: {} elements", result.len());
}

/// scalar-pixel-fkr test: Softmax
#[test]
fn scalar_pixel_fkr_softmax() {
    let mut rng = SimpleRng::new(34567);
    let x = rng.gen_vec(2048);

    let result = scalar_softmax(&x);

    // Verify softmax properties
    assert_eq!(result.len(), 2048);

    // Sum should be 1.0
    let sum: f32 = result.iter().sum();
    assert!(
        (sum - 1.0).abs() < 1e-5,
        "Softmax sum should be 1.0, got {sum}"
    );

    // All values should be in (0, 1)
    for (i, v) in result.iter().enumerate() {
        assert!(*v > 0.0 && *v <= 1.0, "Softmax value at {i} out of range: {v}");
    }

    println!("scalar_pixel_fkr_softmax: sum={:.6}", sum);
}

/// scalar-pixel-fkr test: RoPE
#[test]
fn scalar_pixel_fkr_rope() {
    let mut rng = SimpleRng::new(45678);
    let x = rng.gen_vec(512);
    let (freqs_cos, freqs_sin) = compute_rope_freqs(512, 10000.0);

    let result = scalar_rope(&x, &freqs_cos, &freqs_sin);

    // Verify output dimensions
    assert_eq!(result.len(), 512);
    assert!(result.iter().all(|v| v.is_finite()), "Non-finite in RoPE output");

    // RoPE should preserve norm approximately
    let input_norm: f32 = x.iter().map(|v| v * v).sum::<f32>().sqrt();
    let output_norm: f32 = result.iter().map(|v| v * v).sum::<f32>().sqrt();
    let norm_ratio = output_norm / input_norm;
    assert!(
        (norm_ratio - 1.0).abs() < 0.5, // Allow 50% variation due to frequency mixing
        "RoPE norm ratio too far from 1.0: {norm_ratio}"
    );

    println!("scalar_pixel_fkr_rope: input_norm={:.4}, output_norm={:.4}", input_norm, output_norm);
}

/// scalar-pixel-fkr test: Causal Mask
#[test]
fn scalar_pixel_fkr_causal_mask() {
    let seq_len = 64;
    let mut rng = SimpleRng::new(56789);
    let scores = rng.gen_vec(seq_len * seq_len);

    let result = scalar_causal_mask(&scores, seq_len);

    // Verify causal structure
    assert_eq!(result.len(), seq_len * seq_len);

    // Upper triangle should be NEG_INFINITY
    for i in 0..seq_len {
        for j in (i + 1)..seq_len {
            assert!(
                result[i * seq_len + j] == f32::NEG_INFINITY,
                "Causal mask not applied at [{i}][{j}]"
            );
        }
    }

    // Lower triangle should be unchanged
    for i in 0..seq_len {
        for j in 0..=i {
            assert!(
                result[i * seq_len + j] == scores[i * seq_len + j],
                "Causal mask corrupted lower triangle at [{i}][{j}]"
            );
        }
    }

    println!("scalar_pixel_fkr_causal_mask: {}x{} verified", seq_len, seq_len);
}

/// scalar-pixel-fkr test: Q4_K dequantization
#[test]
fn scalar_pixel_fkr_q4k_dequant() {
    let quantized: Vec<u8> = (0..128).map(|i| i as u8).collect();
    let scale = 0.1;
    let zero_point = 8.0;

    let result = scalar_q4k_dequant(&quantized, scale, zero_point);

    // Each byte produces 2 floats
    assert_eq!(result.len(), 256);

    // Verify dequantization range
    let min_val = result.iter().cloned().fold(f32::INFINITY, f32::min);
    let max_val = result.iter().cloned().fold(f32::NEG_INFINITY, f32::max);

    // With 4-bit values [0,15], zero_point=8, scale=0.1
    // Range should be approximately (-8*0.1, (15-8)*0.1) = (-0.8, 0.7)
    assert!(min_val >= -1.0 && max_val <= 1.0, "Dequant range: [{min_val}, {max_val}]");

    println!("scalar_pixel_fkr_q4k_dequant: range=[{:.3}, {:.3}]", min_val, max_val);
}

// ============================================================================
// SIMD-PIXEL-FKR: SIMD Validation (SPEC Section 3.5.3)
// ============================================================================

use trueno::Vector;

/// Compare two float vectors with tolerance
fn vectors_match(a: &[f32], b: &[f32], tolerance: f32, name: &str) -> bool {
    if a.len() != b.len() {
        eprintln!("{name}: length mismatch {} vs {}", a.len(), b.len());
        return false;
    }

    let mut max_diff = 0.0f32;
    let mut max_diff_idx = 0;

    for (i, (ai, bi)) in a.iter().zip(b.iter()).enumerate() {
        let diff = (ai - bi).abs();
        if diff > max_diff {
            max_diff = diff;
            max_diff_idx = i;
        }
    }

    if max_diff > tolerance {
        eprintln!(
            "{name}: max diff {max_diff:.2e} at index {max_diff_idx} exceeds tolerance {tolerance:.2e}"
        );
        return false;
    }

    println!("{name}: PASS (max_diff={max_diff:.2e})");
    true
}

/// simd-pixel-fkr: Vector operations match scalar baseline
#[test]
fn simd_pixel_fkr_vector_ops() {
    let mut rng = SimpleRng::new(11111);
    let a = rng.gen_vec(10000);
    let b = rng.gen_vec(10000);

    // Scalar baseline
    let scalar_add: Vec<f32> = a.iter().zip(b.iter()).map(|(x, y)| x + y).collect();
    let scalar_mul: Vec<f32> = a.iter().zip(b.iter()).map(|(x, y)| x * y).collect();

    // SIMD implementation
    let va = Vector::from_slice(&a);
    let vb = Vector::from_slice(&b);

    let simd_add = va.add(&vb).expect("SIMD add failed");
    let simd_mul = va.mul(&vb).expect("SIMD mul failed");

    assert!(vectors_match(&scalar_add, simd_add.as_slice(), SIMD_TOLERANCE, "simd_add"));
    assert!(vectors_match(&scalar_mul, simd_mul.as_slice(), SIMD_TOLERANCE, "simd_mul"));
}

/// simd-pixel-fkr: Softmax matches scalar baseline
#[test]
fn simd_pixel_fkr_softmax() {
    let mut rng = SimpleRng::new(22222);
    let x = rng.gen_vec(2048);

    // Scalar baseline
    let scalar_result = scalar_softmax(&x);

    // SIMD implementation
    let v = Vector::from_slice(&x);
    let simd_result = v.softmax().expect("SIMD softmax failed");

    assert!(vectors_match(&scalar_result, simd_result.as_slice(), SIMD_TOLERANCE, "simd_softmax"));
}

/// simd-pixel-fkr: Unaligned input (17 elements - not divisible by SIMD width)
#[test]
fn simd_pixel_fkr_unaligned_17() {
    let mut rng = SimpleRng::new(33333);
    let a = rng.gen_vec(17);
    let b = rng.gen_vec(17);

    // Scalar baseline
    let scalar_add: Vec<f32> = a.iter().zip(b.iter()).map(|(x, y)| x + y).collect();

    // SIMD implementation
    let va = Vector::from_slice(&a);
    let vb = Vector::from_slice(&b);
    let simd_add = va.add(&vb).expect("SIMD unaligned add failed");

    assert!(vectors_match(&scalar_add, simd_add.as_slice(), SIMD_TOLERANCE, "simd_unaligned_17"));
}

/// simd-pixel-fkr: Remainder handling (255 elements)
#[test]
fn simd_pixel_fkr_remainder_255() {
    let mut rng = SimpleRng::new(44444);
    let a = rng.gen_vec(255);
    let b = rng.gen_vec(255);

    // Scalar baseline
    let scalar_mul: Vec<f32> = a.iter().zip(b.iter()).map(|(x, y)| x * y).collect();

    // SIMD implementation
    let va = Vector::from_slice(&a);
    let vb = Vector::from_slice(&b);
    let simd_mul = va.mul(&vb).expect("SIMD remainder mul failed");

    assert!(vectors_match(&scalar_mul, simd_mul.as_slice(), SIMD_TOLERANCE, "simd_remainder_255"));
}

/// simd-pixel-fkr: ReLU activation
#[test]
fn simd_pixel_fkr_relu() {
    let mut rng = SimpleRng::new(55555);
    let x = rng.gen_vec(10000);

    // Scalar baseline
    let scalar_relu: Vec<f32> = x.iter().map(|v| v.max(0.0)).collect();

    // SIMD implementation
    let v = Vector::from_slice(&x);
    let simd_relu = v.relu().expect("SIMD relu failed");

    assert!(vectors_match(&scalar_relu, simd_relu.as_slice(), SIMD_TOLERANCE, "simd_relu"));
}

// ============================================================================
// WGPU-PIXEL-FKR: WebGPU Validation (SPEC Section 3.5.4)
// ============================================================================

#[cfg(feature = "gpu")]
mod wgpu_fkr {
    use super::*;
    use trueno::backends::gpu::GpuBackend;

    /// wgpu-pixel-fkr: Large vector operations
    #[test]
    fn wgpu_pixel_fkr_large_vector() {
        if !GpuBackend::is_available() {
            eprintln!("Skipping WGPU FKR: no GPU available");
            return;
        }

        let mut rng = SimpleRng::new(66666);
        let a = rng.gen_vec(100_000);
        let b = rng.gen_vec(100_000);

        // Scalar baseline
        let scalar_add: Vec<f32> = a.iter().zip(b.iter()).map(|(x, y)| x + y).collect();

        // WGPU implementation (should auto-dispatch to GPU for large vectors)
        let va = Vector::from_slice(&a);
        let vb = Vector::from_slice(&b);
        let wgpu_add = va.add(&vb).expect("WGPU add failed");

        assert!(vectors_match(&scalar_add, wgpu_add.as_slice(), GPU_TOLERANCE, "wgpu_large_vector"));
    }

    /// wgpu-pixel-fkr: Matrix multiply (GPU stress test)
    #[test]
    fn wgpu_pixel_fkr_matmul() {
        if !GpuBackend::is_available() {
            eprintln!("Skipping WGPU matmul FKR: no GPU available");
            return;
        }

        let n = 128; // 128x128 matrix
        let mut rng = SimpleRng::new(77777);
        let a_data = rng.gen_vec(n * n);
        let b_data = rng.gen_vec(n * n);

        // Scalar baseline (naive O(n^3))
        let mut scalar_result = vec![0.0f32; n * n];
        for i in 0..n {
            for j in 0..n {
                let mut sum = 0.0f32;
                for k in 0..n {
                    sum += a_data[i * n + k] * b_data[k * n + j];
                }
                scalar_result[i * n + j] = sum;
            }
        }

        // WGPU implementation via Matrix
        use trueno::Matrix;
        let a = Matrix::from_vec(n, n, a_data).expect("Matrix A creation failed");
        let b = Matrix::from_vec(n, n, b_data).expect("Matrix B creation failed");
        let wgpu_result = a.matmul(&b).expect("WGPU matmul failed");

        // Matmul accumulates errors, so use larger tolerance
        let matmul_tolerance = GPU_TOLERANCE * n as f32;
        assert!(vectors_match(&scalar_result, wgpu_result.as_slice(), matmul_tolerance, "wgpu_matmul_128x128"));
    }

    /// wgpu-pixel-fkr: Softmax (numerical stability on GPU)
    #[test]
    fn wgpu_pixel_fkr_softmax() {
        if !GpuBackend::is_available() {
            eprintln!("Skipping WGPU softmax FKR: no GPU available");
            return;
        }

        let mut rng = SimpleRng::new(88888);
        let x = rng.gen_vec(4096);

        // Scalar baseline
        let scalar_result = scalar_softmax(&x);

        // WGPU implementation
        let v = Vector::from_slice(&x);
        let wgpu_result = v.softmax().expect("WGPU softmax failed");

        assert!(vectors_match(&scalar_result, wgpu_result.as_slice(), GPU_TOLERANCE, "wgpu_softmax"));
    }
}

// ============================================================================
// PTX-PIXEL-FKR: CUDA Validation (SPEC Section 3.5.5)
// ============================================================================

// PTX tests are in trueno-gpu crate (requires CUDA feature)
// See trueno-gpu/tests/ptx_pixel_fkr.rs

/// Placeholder test documenting PTX FKR location
#[test]
fn ptx_pixel_fkr_location() {
    println!("PTX Pixel FKR tests are in trueno-gpu crate:");
    println!("  cargo test -p trueno-gpu --test pixel_fkr --features cuda");
    println!("");
    println!("Tests validate:");
    println!("  - QuantizeKernel (Issue #67 prevention)");
    println!("  - Q4_K dequantization");
    println!("  - GEMM kernels");
    println!("  - Softmax PTX");
}

// ============================================================================
// REGRESSION SUMMARY
// ============================================================================

/// Summary test that reports all FKR status
#[test]
fn pixel_fkr_summary() {
    println!("");
    println!("========================================");
    println!("  TRUENO-SPEC-013 Pixel FKR Summary");
    println!("========================================");
    println!("");
    println!("  scalar-pixel-fkr: Baseline truth tests");
    println!("    - rmsnorm_4096");
    println!("    - silu_8192");
    println!("    - softmax_2048");
    println!("    - rope_512");
    println!("    - causal_mask_64x64");
    println!("    - q4k_dequant_256");
    println!("");
    println!("  simd-pixel-fkr: SIMD vs scalar (+-1 ULP)");
    println!("    - vector_ops_10000");
    println!("    - softmax_2048");
    println!("    - unaligned_17");
    println!("    - remainder_255");
    println!("    - relu_10000");
    println!("");
    #[cfg(feature = "gpu")]
    {
        println!("  wgpu-pixel-fkr: WGPU vs scalar (+-2 ULP)");
        println!("    - large_vector_100000");
        println!("    - matmul_128x128");
        println!("    - softmax_4096");
    }
    #[cfg(not(feature = "gpu"))]
    {
        println!("  wgpu-pixel-fkr: SKIPPED (gpu feature disabled)");
    }
    println!("");
    println!("  ptx-pixel-fkr: See trueno-gpu crate");
    println!("");
    println!("========================================");
}
